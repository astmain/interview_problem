# *02_js笔记*

小鹿线前端开发 视频讲解    https://www.bilibili.com/video/BV15z4y1a7MN/?p=90

掘金博客超详细                   https://juejin.cn/post/6996841019094335519

# 01_js由哪三部分组成

ES_ECMAScript：JS的核心内容，描述了语言的基础语法，比如var，for，数据类型（数组、字符串）

DOM_文档对象模型：DOM把整个HTML页面规划为元素构成的文档

BOM_浏览器对象模型 :对浏览器窗口进行访问和操作

.

# 02_js内置对象7个

常用对象:String,Boolean,Number,Arrary,Object,Function, Math,Date,RegExp...

Math:asb(),sqrt(),max(),min()

Date:new Date(),getYear()

Array:map()

String:concat(), length, slice(), split()

.

# 03_操作数组常用方法16种

push(),pop(),sort(),splice(),unshift(),shift(),reverse(),concat(),join(),map(),filter(),ervery(),some(),reduce(),isArray(),findIndex(),

7种会改变原数组:push(),pop(),unshift(),shift(),sort(),reverse(),splice(),

# 04_js对数据类型的检查方法4种

判断数组的方式有哪些

`1.Array.isArray()` 是ES5引入的数组检测的标准方法

`2.Object.prototype.toString.call()`      '[object Array]

3.lodash  检查是不是存数组,还是数组字典



```
                    console.error("//typeof （）对于基本数据类型没问题，遇到引用数据类型就不管用")
                    console.log(typeof (123))//number
                    console.log(typeof ([1, 2, 3]))//object

                    console.error("//instanceof （）只能判断引用数据类型，不能判断基本数据类型")
                    console.log([] instanceof Array)//true
                    console.log("abc" instanceof String)//false

                    console.error('//constructor 几乎可以判断基本数据类型和引用数据类型；如果声明了一个构造函数，并把它的原型指向了Array')
                    console.log(('abc').constructor === String)


                    console.error('//Object.prototype.toString.call() 完美解决判断类型')
                    let opt = Object.prototype.toString
                    console.log(opt.call('abc'))
                    console.log(opt.call(2))
                    console.log(opt.call([]))
                    console.log(opt.call({}))
                    console.log(opt.call({ a: 111 }))
                    console.log(opt.call(new Date()))
                    console.log(opt.call(undefined))
                    console.log(opt.call(null))
                    console.log(opt.call(function () { }))
                    console.log(opt.call(/123/))
                    // consble.log(Object.prototype.toString.call(true) == '[object Boolean]')
```

.

# 05_闭包的有点

函数嵌套函数，内部函数被外部函数返回并保存下来时，就会产生闭包

使用场景：防抖，节流，函数嵌套避免全局污染

特点:可以重复利用变量,并且这个变量不会污染全局的一种机制;这个变量是一直保存再内存中,不会被垃圾回收机制回收

缺点:闭包较多的时候,会消耗内存,导致页面的性能下降,在IE浏览器中才会导致内存泄漏

.

# 06_前端内存泄漏4种情况

JS里已经分配内存地址的对象,但是由于长时间没有释放或者没办法清除,

造成长期占用内存的现象,会让内存资源大幅浪费，最终导致运行速度慢，甚至崩溃的情况。

原本js有垃圾回收机制,但是因为以下4个因素,会没法正常的垃圾回收

因素：1一些未声明直接赋值的变量；2一些未清空的定时器；3过度的闭包；4一些引用元素没有被清除。

.

# 07_事件委托是什么

又叫事件代理,原理就是利用了事件冒泡的机制来实现,也就是说把子元素的事件绑定到了父元素的身上如果子元素组织了事件冒泡，那么委托也就不成立·阻止事件冒泡: event.stopPropagatio事件代理n()

addEventListener('click'，函数名，true/false）默认是false（事件冒泡）， true （事件捕获)好处：提高性能，减少事件的绑定，也就减少了内存的占用。

.

# 08_基本数据类型和引用数据类型有什么区别

基本数据类型:String,Number,,Boolean,undefined,null

    基本数据类型保存在栈内存当中，保存的就是一个具体的值

引用数据类型:(复杂数据类型)Object,Function,Arrary

    保存在堆内存当中，声明一个引用类型的变量，它保存的是引用类型数据的地址

    假如声明两个引用类型同时指向了一个地址的时候，修改其中一个那么另外一个也会改变

    let obj1 = { name:"张三", age:18 }

    let obj2 = obj1

    obj2.name = "李四"

    console.log(`${1}>obj1=======:`, obj1.name)

    console.log(`${1}>obj2=======:`, obj2.name)

.

# 09_原型链是什么

原型就是一个普通对象,它是为构造函数的实例共享属性和方法;所有实例中引用的原型都是同一个对象

使用prototype可以把方法挂在原型上，内存值保存一份

__proto__可以理解为指针,实例对象中的属性,指向了构造函数的原型(prototype)

一个实例对象在调用属性和方法的时候,会依次从实例本身、构造函数原型、原型的原型上去查找

.

# 10_new具体做了什么

1.先创建一个空对象

2.把空对象和构造函数通过原型链进行链接

3.把构造函数的this绑定到新的空对象身上

4·根据构建函数返回的类型判断,如果是值类型,则返回对象,如果是引用类型,就要返回这个引用类型

.

# 11_js继承4种方法

方法1_原型链继承

说明: 让一个构造函数的原型是另一个类型的实例，那么这个构造函数new出来的实例就具有该实例的属性。

优点：写法方便简洁，容易理解。

缺点：对象实例共享所有继承的属性和方法。无法向父类构造函数传参。

.

方法2_借用构造函数继承

说明: 子类型构造函数的内使用 apply()或call()方法将父对象的构造函数绑定在子对象上。
优点：解决了原型链实现继承的不能传参的问题和父类的原型共享的问题。

缺点：借用构造函数的缺点是方法都在构造函数中定义，因此无法实现函数复用。在父类型的原型中定义的方法,对子类型而言也是不可见的,结果所有类型都只能使用构造函数模式。

.

方法3_组合继承
说明: 原型链 和 借用构造函数 的组合到一块.

优点：就是解决了原型链继承和借用构造函数继承造成的影响。

缺点：是无论在什么情况下，都会调用两次父类构造函数：一次是在创建子类原型的时候，另一次是在子类构造函数内部

.

方法4_Class继承

说明:Class通过extends关键字实现继承，其实质是先创造出父类的this对象，然后用子类的构造函数修改this·

子类的构造方法中必须调用super方法，且只有在调用了super()之后才能使用this，因为子类的this对象是继承父类的this对象,然后对其进行加工,而super方法表示的是父类的构造函数,用来新建父类的this对象

优点:语法简单易懂,操作更方便。

缺点:并不是所有的浏览器都支持class关键字

.

# 12_js设计原理是什么

js引擎:v8引擎语法解析

运行上下文:浏览器window,dom,让js驱动

调用栈:单线程,主线程渲染工作

事件循环:调用栈空的时候,把任务放到循环里面执行

回调:执行一个函数的同时执行另一个函数，且因为另一个函数是作为实参传递，另一个函数是可以自定义的；主函数可以处理数据外，回调函数也可以进一步处理数据，并返回想要的结果。

.

# 13_this指向问题7个关键点

1,全局对象中的this  :  指向的是window

2,全局作用域或者普通函数中的this  :  指向全局window

3,this永远指向最后调用它的那个对象  :  在不是箭头函数的情况下

4,new 关键词  :  改变了this的指向

5,apply,call,bind  :  可以改变this指向，不是箭头函数

6,箭头函数中的this  :1它的指向在定义的时候就已经确定了,2箭头函数它没有this,看外层是否有函数,有就是外层函数的this,没有就是window

7,匿名函数中的this  :  永远指向了window,匿名函数的执行环境具有全局性,因此this指向window

.

# 14_script标签async和defer区别3种情况:

没有async和defer这两个属性的时候:浏览器会立刻加载并执行指定的脚本

有async:(不保证加载顺序)加载和渲染后面元素的过程将和script的加载和执行并行进行(异步)

有defer:(保证加载顺序)加载和渲染后面元素的过程将和script的加载并行进行(异步),但是它的执行事件要等所有元素解析完成之后才会执行

.

# 15_setTimeout最小执行时间4毫秒setInterval最小执行时间10毫秒

HTML5规定

setTimeout最小执行时间是4ms

setInterval最小执行时间是10ms

.

# 16_ES6和ES5区别

JS的组成:ECMAScript,BOM,DOm

ES5:ECMAScript5,2009年ECMAScript的第五个修订,ECMAScript2009

ES6:ECMAScript6,2015年ECMAScript的第六个修订,ECMAScript2015,是JS的下一个版本标准

.

# 17_ES6的12个常用特性

1.新增块级作用域（let,const)

    不存在变量提升

    存在暂时性死区的问题

    块级作用域的内容

    不能在同一个作用域内重复声明

2.新增了定义类的语法糖(class)

3,新增了一种基本数据类型(symbol)

4.新增了解构赋值

    从数组或者对象中取值，然后给变量赋

5.新增了函数参数的默认值

6.给数组新增了API

7.对象和数组新增了扩展运算符

৪.Promise

    解决回调地狱的问题。

    自身有all, reject, resolve,race方法

    原型上有then,catch

    把异步操作队列化

    三种状态: pending初始状态，fulfilled操作成功,rejected操作失败

    状态： pending -> fulfilled;pending -> rejected 一旦发生，状态就会凝固，

9.新增了模块化(import,export)

10.新增了set和map数据结构

    set就是不重复map的key的类型不受限制

11.新增了generator

12.新增了箭头函数

    不能作为构造函数使用，不能用new

    箭头函数就没有原型

    箭头函数没有arguments

    箭头函数不能用call,apply,bind去改变this的执行

    this指向外层第一个函数的thisI发送

.

# 18_call,aply, bind三者有什么区别

都是改变this指向和函数的调用，call和apply的功能类似，只是传参的方法不同

call方法传的是一个参数列表,call方法的性能要比apply好一些，所以call用的更多一点

apply传递的是一个数组

bind传参后不会立刻执行，会返回一个改变了this指向的函数，这个函数还是可以传参的，bind()（)

.

# 19_用递归的时候有没有遇到什么问题

如果一个函数内可以调用函数本身，那么这个就是递归函数

函数内部调用自己

特别注意:写递归必须要有退出条件return

.

# 20_如何实现一个深拷贝

深拷贝就是完全拷贝一份新的对象,会在堆内存中开辟新的空间,拷贝的对象被修改后,原对象不受影响主要针对的是引用数据类型

1.扩展运算符,缺点这个方法只能实现第一层，当有多层的时候还是浅拷贝

2.JSON.parse(JSON.stringify())缺点不会拷贝内部函数

3.利用递归函数实现,指定函数完美解决

.

# 21_说一下事件循环

JS是一个单线程的脚本语言

主线程->执行栈->任务队列(同步任务,异步任务) ->微任务->宏任务

主线程->执行栈>执行同步任务,然后才去执行任务队列里的任务,如果在执行宏任务之前有微任务,那么要先执行微任务全部执行完之后等待主线程的调用，调用完之后再去任务队列中查看是否有异步任务，这样一个循环往复的过程就是事件循环！

.

# 22_ajax是什么

创建交互式网页在不重新加载整个网页的前提下，与服务器交换数据并更新部分内容通过XmlHttpRequest对象向服务器发送异步请求,然后从服务器拿到数据

1.创建XmlHttpRequest对象xhr

2.通过xhr对象里的open()方法和服务器建立连接

3,构建请求所需的数据,并通过xhr对象的send()发送给服务器

4,通过xhr对象的onreadystate change事件监听服务器和你的通信状态5.接收并处理服务器响应的数据结果

6,把处理的数据更新到HTML页面上

.

# 23_get和post有什么区别

get一般是获取数据， post一般是提交数据

get:1get参数放在url上安全性比较差，2get刷新服务器或退回是没有影响的 ,3get时会被缓存,4get会保存在浏览器历史记录,5get只能进行url编码,

post:1post参数放在body中 , 2post请求退回时会重新提交数据 ,3post请求不会被缓存 ,4post不会保存浏览器历史记录 ,5post请求支持很多种(图片,excel,word,等)

.

# 24_promise的内部原理是什么

Promise对象,封装了一个异步操作并且还可以获取成功或失败的结果,Promise主要就是解决回调地狱的问题差

三种状态:

    1.只有两种运行情况:  pending初始状态 -> fulfilled成功状态； pending初始状态 -> rejected失败状态

    2.一旦发生，状态就会凝固，不会再变首先就是我们无法取消promise，

    3.一旦创建它就会立即执行，不能中途取消如果不设置回调，promise内部抛出的溢出无法反馈到外面若当前处于pending状态时,无法得知目前在哪个阶段。

原理：Promise首字母大写说明是一个构造函数

    1.首先构造一个Promise实例

    2.实例需要传递函数的参数,这个函数有两个形参,分别都是函数类型,一个是resolve,另一个是reject

    3.promise上还有then方法，这个方法就是来指定状态改变时的确定操作，resolve是执行第一个函数，reject是执行第二个函数

.

# 25_promise和async await的区别是什么

1.都是处理异步请求的方式

2.promise是ES6, async await 是ES7的语法

3.async await是基于promise实现的,他和promise都是非阻塞性的

优缺点：

1.promise是返回对象我们要用then, catch方法去处理和捕获异常,并且书写方式是链式,容易造成代码重叠,不好维护

2.async await优点是让代码看起来像同步一样,只要遇到await就会立刻返回结果

.

# 26_浏览器的4种存储方式

1.cookies

    H5标准前的本地存储方式,兼容性好，请求头自带cookie

    存储量小，资源浪费，使用麻烦（封装)

    不能进行跨域，只能存储字符串

    存储容量通常在4097

2.localstorage

    H5加入的以键值对为标准的方式

    操作方便，永久存储，兼容性较好

    保存值的类型被限定（键是字符串，值是JSON字符串），浏览器在隐私模式（IE）下不可读取，不能被爬虫

    存储容量通常在5MB到10MB之间

3.sessionstorage

    当前页面关闭后就会立刻清理，会话级别的存储方式。但是刷新网页不会清除,是一个临时的存在。

    存储容量通常在5MB到10MB之间

4.indexedDB

    H5标准的存储方式，，他是以键值对进行存储，可以快速读取，适合WEB场景

    存储容量通常在 250MB,甚至没有上限

.

# 27_token存在sessionstorage还是loaclstorage

token：验证身份的令牌，一般就是用户通过账号密码登录后，服务端把这些凭证通过加密等一系列操作后得到的字符串

1.存loaclstorage种,

   后期每次请求接口都需要把它当作一个字段传给后台

   存在localstorage中,容易被xss攻击,但是如果做好了对应的措施,那么是利大于弊

2.存cookie中，

   会自动发送，缺点就是不能跨域

   如果存在cookie中会有CSRF攻击

.

# 28_token的登录流程

1.客户端用账号密码请求登录

2.服务端收到请求后,需要去验证账号密码

3.验证成功之后,服务端会签发一个token,把这个token发送给客户端

4.客户端收到token后保存起来,可以放在cookie也可以是localstorage

5.客户端每次向服务端发送请求资源的时候,都需要携带这个tokenI

6·服务端收到请求,接着去验证客户端里的token,验证成功才会返回客户端请求的数据

.

# 29_页面渲染的过程是怎样的

1.DNS解析

2.建立TCP连接

3.发送HTTP请求

4.服务器处理请求,返回数据

5.渲染页面:1浏览器获取HTML和CSS资源,2HTML解析成DOM树,3CSS解析成CSSOM,4DOM和CSSOM合并为渲染树,5布局,6渲染树每个节点渲染到屏幕

6.断开TCP连接

.

# 30_DOM树和渲染树有什么区别

DOM树是和HTML标签一一对应的，包括head和隐藏元素

渲染树是不包含head和隐藏元素

.

# 31_精灵图和base64的区别是什么

精灵图:

    把多张小图整合到一张大图上,利用定位的一些属性把小图显示在页面上,当访问页面可以减少请求,提高加载速度

base64:

    传输8Bit字节代码的编码方式,把原本二进制形式转为64个字符的单位,最后组成字符串

    base64是会和html css一起下载到浏览器中,减少请求,减少跨域       问题,但是一些低版本不支持,若base64体积比原图片大，不利于css的加载。

.

# 32_svg格式了解多少

基于XML语法格式的图像格式,可缩放矢量图,SVG是属于对图像形状的描述,本质是文本文件,体积小,并且不管放大多少倍都不会失真

1.SVG可直接插入页面中，成为DOM一部分，然后用JS或CSS进行操作 `<svg></svg>`

2.SVG可作为文件被引入 `<img src="pic.svg" />`

3.SVG可以转为base64引入页面

.

# 33_了解过JWT吗

JSON web Token通过JSON形式作为在web应用中的令牌,可以在各方之间安全的把信息作为JSON对象传输信息传输、授权JWT的认证流程

1.前端把账号密码发送给后端的接口

2.后端核对账号密码成功后,把用户id等其他信息作为JWT负载,把它和头部分别进行base64编码拼接后签名,形成一个JWT (token)。

3.前端每日请求时都会把JWT放在HTTP请求头的Authorization字段内

4.后端检查是否存在,如果存在就验证JWT的有效性(签名是否正确, token是否过期)

5.验证通过后后端使用JWT中包含的用户信息进行其他的操作,并返回对应结果

6.简洁、包含很多用户信息、因为Token是JSON加密的形式保存在客户端,所以JWT是跨语言的,原则上是任何web形式都支持。

.

# 34_npm的底层环境是什么

npm的组成:网站、注册表、命令行工具

node package manager,node的包管理和分发工具,已经成为分发node模块的标准,是JS的运行环境

.

# 35_HTTP协议规定的协议头和请求头有什么

1.请求头信息：

    Accept:浏览器告诉服务器所支持的数据类型

    Host:浏览器告诉服务器我想访问服务器的哪台主机

    Referer:浏览器告诉服务器我是从哪里来的(防盗链)

    User-Agent:浏览器类型、版本信息

    Date:浏览器告诉服务器我是什么时候访问的

    Connection:连接方式

    Content-Type：指定请求体的MIME类型，例如application/json、application/x-www-form-urlencoded等。

    Cookie:指定请求的Cookie信息，用于跟踪用户会话。

    Cache-Control：指定请求或响应的缓存策略，例如max-age、no-cache、no-store等

    X-Request-With：请求方式,例如XMLHttpRequest。

    Accept-Encoding：指定客户端能够接受的编码方式，例如gzip、deflate等。

2.响应头信息：

    Location:这个就是告诉浏览器你要去找谁

    Server:告诉浏览器服务器的类型

    Content-Type:告诉浏览器返回的数据类型，例如application/json、application/x-www-form-urlencoded等。

    Refresh：控制了的定时刷新

.

# 36_说一下浏览器的缓存策略

强缓存(本地缓存):不发起请求,直接使用缓存里的内容,浏览器把js, css, image等存到内存中,下次用户访问直接从内存中取,提高性能

协商缓存(弱缓存):需要像后台发请求,通过判断来决定是否使用协商缓存,如果请求内容没有变化,则返回304,浏览器就用缓存里的内容

强缓存的触发：

    HTTP1.0:时间戳响应标头

    HTTP1.1:Cache-Control响应标头

协商缓存触发：

    HTTP1.0:请求头: if-modified-since响应头: last-modified

    HTTP1.1:请求头: if-none-match响应头: Etag

.

# 37_同源策略是什么

http:// www. aaa.com:8080/index/vue.js

协议子域名 主域名 端口号资源同源策略是浏览器的核心,如果没有这个策略就会遭受网络攻击

主要指的就是协议+域名+端口号三者一致，若其中一个不一样则不是同源，**会产生跨域三个允许跨域

加载资源的标签: img link script

跨域是可以发送请求，后端也会正常返回结果，只不过这个结果被浏览器拦截了！

JSONP,CORS,websocket,反向代理

.

# 38_防抖和节流是什么

都是应对页面中频繁触发事件的优化方案

防抖：避免事件重复触发,使用场景：1.频繁和服务端交互 2.输入框的自动保存事件

节流：把频繁触发的事件减少，每隔一段时间执行 使用场景：scroll事件

.

# 39_解释一下什么是json

JSON是一种纯字符串形式的数据,它本身不提供任何方法,适合在网络中进行传输

JSON数据存储在.json文件中,也可以把JSON数据以字符串的形式保存在数据库、Cookise中

JS提供了JSON.parse() JSON.stringify()

什么时候使用json:定义接口;序列化;生成token;配置文件package.json

.

# 40_当数据没有请求过来的时候该怎么做

可以在渲染数据的地方给一些默认的值

if判断语句

.

# 41_有没有做过无感登录

1.在相应其中拦截，判断token返回过期后,调用刷新token的接口

2.后端返回过期时间，前端判断token的过期时间，去调用刷新token的接口

3.写定时器，定时刷新token接口

4流程：

    1.登录成功后保存token和refresh_token

    2.在响应拦截器中对401状态码引入刷新token的api方法调用

    3.替换保存本地新的token

    4.把错误对象里的token替换

    5.再次发送未完成的请求

    6·如果refresh_token过期了,判断是否过期,过期了就清楚所有token重新登录

.

# 42_大文件上传是怎么做的

分片上传：

1.把需要上传的文件按照一定的规则,分割成相同大小的数据块

2.初始化一个分片上传任务，返回本次分片上传的唯一标识

3.按照一定的规则把各个数据块上传

4·发送完成后,服务端会判断数据上传的完整性,如果完整,那么就会把数据库合并成原始文件

5.断点续传：服务端返回,从哪里开始 浏览器自己处理

.

# 43_解决了哪些移动端的兼容问题

1.当设置样式overflow:scroll/auto时，Ios上滑动会卡顿-webkit-overflow-scrolling:touch;

2.在安卓环境下placeholder文字设置行高时会偏上input有placeholder属性的时候不要设置行高

3.移动端字体小于12px时异常显示应该先把在整体放大一倍,然后再用transform进行缩小

4.ios下input按钮设置了disabled属性为true显示异常input[typy=button]{ opcity:1}

5.安卓手机下取消语音输入按钮input::-webkit-input-speech-button{ display:none}

6.IOS下取消input输入框在输入引文首字母默认大写 `<input autocapitalize='off' autocorrect='off'/>`

7.禁用IOS和安卓用户选中文字添加全局css样式: -webkit-user-select:none

8.禁止IOS弹出各种窗口-webkit-touch-callout:none

9·禁止1OS识别长串数字为电话添加meta属性 <meta conten='telephone=no'Iname='format-detec'>

.
